# Session Learnings — 2026-02-11 07:46

## Documentation Architecture

- **ENTITIES.md is more useful than HOW-TO.md or PLAYBOOK.md.** The first attempt (HOW-TO.md) framed things as procedures; the second reframing as an entity guide captures the real structure — what entities exist, what's nested inside them, and what you can ask CC to do. The document serves the human as a menu and CC as a reference.
- **Documents that duplicate what CC can already infer from schemas have low utility.** The vendor "how to add" recipe was essentially an indirection layer over the schema. The entity guide earns its value by documenting what's *not* in schemas — sub-resource nesting, cross-entity credential placement, vocabulary mappings.

## Schema Design

- **`aliases` is an Obsidian-native field worth including in entity schemas.** It enables wikilink resolution from alternate names (e.g., `[[Visual Studio Code]]` → `VSCode.md`, `[[DO]]` → `DigitalOcean.md`). Added to software schema at v1 (pre-notes) and vendor schema at v2 (backfilled 8 notes).
- **`repository` belongs in frontmatter for software entities** — queryable, unlike a body link. Not all software has a repo, so it's optional with default `""`.
- **Flexible `##` heading structure works better for software than for vendors.** Vendors have a natural `##` = account convention. Software notes vary too much (by topic, by version, by integration) to prescribe a heading convention. Key line (blockquote) recommended for complex notes.
- **`type` list handles classification without extra fields.** Secondary values like `[software, cli-tool]` or `[software, desktop-app]` replace the old hierarchical tag system (`software/desktop`, `software/javascript/library`) without needing separate platform/category fields.

## Entity Classification

- **The vendor vs. software boundary rule:** If you have an *account* with it and consume it as a *service*, it's a vendor. If you *install/run* it locally or it's a tool/library, it's software. SaaS products (Otter AI, Stream) are vendors; desktop apps and CLIs (Claude Code, JumpCut) are software.
- **Products within a vendor can be separate software notes.** Claude (web/desktop), Claude Code (CLI), and Claude Desktop are 3 separate software notes even though Anthropic is the vendor. The vendor note holds the account/API keys; the software notes hold usage patterns.
- **Credentials placement is case-by-case.** License keys and tool-specific logins go in the software note. Purchase history and API keys tied to a vendor account go in the vendor note. The goal is "where would I look for this first?"

## Migration Patterns

- **Old vault notes often contain compound entities.** "Cloudflare + PeerLoop" is not a new entity — it's a new account section within an existing vendor note. CC should always check for existing notes before creating new ones.
- **Most old notes are stubs.** Of ~35 old notes migrated, fewer than 10 had meaningful content. Creating schema-compliant stubs is still valuable — they establish the wikilink targets and frontmatter for future content.
- **Obsidian reference content (cheatsheets, tools) fits naturally as sections within the Obsidian software note** rather than as separate reference files.

---
## Continued — 10:09

## Person Entity Design

- **Aliases are critical for people notes.** Filenames are `{FirstLast}.md` (no spaces) but people naturally write `[[Gabriel Rymberg]]` or `[[Gabriel]]`. The `aliases` field must include the spaced full name and short names. Without this, wikilinks from daily notes won't resolve.
- **Obsidian alias collisions fail silently.** When two notes share an alias, Obsidian resolves `[[Mike]]` to one of them non-deterministically — no warning. Autocomplete handles disambiguation at entry time, so short aliases are acceptable at low volume. Check for collisions when creating new people or migrating old daily notes.
- **No `organization` field needed for people.** Org links work better as wikilinks in the body (`[[CenterForUnity]]`, `[[ForBusinessSake]]`) — avoids forcing a frontmatter field that doesn't apply to family/friends.
- **Relationship classification via `type` secondary values works well.** `[person, client]`, `[person, family]`, `[person, friend]`, `[person, vendor-contact]`. The old vault's tag hierarchy (`person/client/pm`) maps cleanly — PM is a role noted in the body, not a type value.

## Project Entity Design

- **Skill decoupling pays off for projects.** `/cco-project-init` was doing two things: vault folder creation and repo CLAUDE.md update. Splitting into `/cco-project-init` (vault-only) and `/cco-project-link-repo` (repo linking) means the vault structure works for any project — hobby, in-house, planning-only — not just coding projects with repos.
- **Multi-phase projects work as regular projects with parent links.** An umbrella project (Xlate) holds business info and a phases table; each phase (XlatePilot) is a full project with its own folder and independent status. No schema changes needed — just wikilinks in the body. Simple, extensible, uses existing conventions.
- **Project `status` field captures lifecycle cleanly.** `active`, `paused`, `completed`, `abandoned` — covers all real states. Combined with the `type` secondary value (`client-work`, `hobby`, `in-house`, `research`) this gives good queryability without over-engineering.

## Migration Patterns (continued)

- **Old vault projects have more noise than signal.** Dataviewjs queries, template scaffolding, and stub sections dominate most notes. The useful content is: project info (FDS #, client, invoice prefix), background narrative, key decisions, and invoices. Strip everything else.
- **Invoice data belongs in the project note.** A simple table (invoice #, block, amount, PDF filename) is sufficient. The old vault's separate invoice notes with dataviewjs queries add no value in the new system.
- **Name unification requires aliases, not renaming.** The Meristics/frasergorrie.com/Technifar tangle resolved cleanly: Meristics = the project, Technifar = the business entity, aliases catch all historical names. The key insight is separating the *thing being built* from the *entity that owns it*.
- **"Client work done for free" is still client-work.** The relationship determines the type, not the payment. StickerHardlyKnowHer is `[project, client-work]` because it's built for Katie as a client, even though it's free.
