# Session Decisions — 2026-02-09 17:48

---
## Continued — 19:53

## Decision 1: PeerLoop Branch for Vault Integration Changes

**Context**: CLAUDE.md needed a Vault Integration section added, but main branch was very out of date.

**Options Considered**:
1. Make changes on main
2. Create branch from staging called `xx3` ← Chosen
3. Create a feature branch with a descriptive name

**Decision**: Create `xx3` from staging for all PeerLoop repo changes related to vault integration.

**Rationale**: User identified that main was stale. Staging has the current code. The `xx3` naming follows the user's existing branch naming convention (jfg-dev, jfg-dev-2, etc. suggest iterative branches).

## Decision 2: Skills as Markdown Prompts (Not Code)

**Context**: The 4 `cco-*` skills needed to be implemented. Could be code (TypeScript/Python scripts) or CC prompt files.

**Options Considered**:
1. TypeScript scripts executed by CC
2. Python scripts executed by CC
3. Markdown prompt files in `~/.claude/commands/` ← Chosen

**Decision**: Implement all 4 skills as markdown prompt files that CC interprets and executes step-by-step.

**Rationale**: Markdown prompts are immediately testable, require no build step, and leverage CC's ability to read/write files directly. The skills are orchestration workflows (read this, write that, parse this), not compute-heavy operations. If any step needs refinement, editing the markdown is instant.

## Decision 3: Defer /cco-session-close E2E Test

**Context**: Integration testing was nearly complete, but `/cco-session-close` requires a real repo with git commits.

**Options Considered**:
1. Simulate with fake git history
2. Test against PeerLoop repo now ← Considered
3. Defer to first real use ← Chosen

**Decision**: Skip the `/cco-session-close` end-to-end test and validate it during the first real session close on PeerLoop.

**Rationale**: The skill integrates `/q-git-history` which is already battle-tested. Simulating git history adds complexity without much confidence. First real use will be a better test.

## Decision 4: Meristics Project Folder Created Ad-Hoc

**Context**: During `/cco-process-daily` testing, the Slack card referenced `[[Meristics]]` which had no project folder.

**Options Considered**:
1. Skip entirely and warn ← Per spec
2. Create minimal folder for task file ← Chosen
3. Run `/cco-project-init Meristics`

**Decision**: Created `projects/meristics/` with just the task file during processing. Full project init deferred.

**Rationale**: The skill spec says to create the task file if missing but warn about the missing project log. This was the correct behavior — partial setup is better than losing the extracted task.

## Decision 5: DECISIONS.md as Authoritative Net Decisions File

**Context**: Decisions were duplicated across CLAUDE.md (Key Design Decisions section), PLANNING.md (Resolved Questions), and session Decisions files. Updating one didn't update the others.

**Options Considered**:
1. Keep decisions in CLAUDE.md as a quick-reference summary ← Previous approach
2. Create DECISIONS.md as single source of truth, remove decisions from other files ← Chosen
3. Keep decisions only in PLANNING.md

**Decision**: Create `DECISIONS.md` as the authoritative file for all net decisions. Each file has a unique role: CLAUDE.md = CC guidance, PLAN.md = task tracking, DECISIONS.md = net decisions, PLANNING.md = full design rationale.

**Rationale**: "Net" means only the current decision survives — if a decision made Monday is changed Friday, only Friday's version appears. This eliminates staleness from duplicated decision content. CLAUDE.md now has a Key Files table pointing to DECISIONS.md instead of inlining decisions.

---
## Continued — 08:08 (session 4)

## Decision 6: Folders for Containment, Frontmatter for Classification

**Context**: Discussing how to classify notes (projects, vendors, people, software). Folders force single classification — a note can only live in one folder. Software like VS Code could be an editor, dev tool, desktop app, browser extension.

**Options Considered**:
1. Folder-based classification (current approach for card types) ← Previous
2. Frontmatter-based classification with folders only for containment ← Chosen

**Decision**: Use folders when a group of related files needs to live together (containment). Use frontmatter `type` field for classification. Never rely on folder location as the primary way to identify what a note is.

**Rationale**: Folders force a single classification. Frontmatter is multi-dimensional and queryable via Dataview.

## Decision 7: `type` Field as Multi-Valued List

**Context**: If `type` is single-valued, it has the same problem as folders — forces one classification.

**Options Considered**:
1. Single-valued `type` with separate `tags` field for cross-cutting ← Considered
2. Multi-valued `type` list ← Chosen

**Decision**: `type` is always a list. `type: [vendor, service-provider]`. Query with `WHERE contains(type, "vendor")`.

**Rationale**: Avoids the single-classification problem. No need for a separate `tags` field — `type` handles all classification dimensions.

## Decision 8: One Note Per Entity

**Context**: Vendor notes are a mess — vacillating between monolithic (one huge note) and atomic (one note per account/service/credential combination). Both have problems.

**Options Considered**:
1. One note per vendor with everything inside ← Chosen
2. Atomic sub-notes for accounts, services, credentials
3. Hybrid with hub note + linked sub-notes

**Decision**: One note per entity (vendor, person, software, etc.). Organize the body by project when multiple projects reference the entity. Split into sub-notes only when a single note becomes unwieldy — not preemptively.

**Rationale**: One file = easy to find (Grep), easy to maintain (one place to update), easy to query (consistent frontmatter). Atomic sub-notes create navigation overhead and go stale faster.

## Decision 9: Entity Schemas — Yes; Generic `/cco-create` Skill — No

**Context**: Should entity types (vendor, person, software) have schemas? Should there be a generic creation skill?

**Options Considered**:
1. Schemas + generic `/cco-create` skill for all types
2. Schemas for reference, manual creation, `/cco-migrate-schema` for backfill ← Chosen
3. No schemas for entities — just cards

**Decision**: Each entity type gets a schema in `reference/schemas/` defining consistent frontmatter. Notes are created manually using the schema as a reference. `/cco-migrate-schema` backfills schema changes to existing notes. No generic `/cco-create` skill — volume is too low to justify. `/cco-project-init` remains for projects (which need containment).

**Rationale**: The schema's value is consistency and queryability, not creation automation. You create a vendor note once; you query it repeatedly. The schema ensures every vendor note has the same frontmatter so `WHERE contains(type, "vendor")` always works.
