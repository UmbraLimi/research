# Session Learnings — 2026-02-09 17:48

## Architecture & Design

- **Single vault access tier is simpler than folder-based tiers.** The original design had DENY/REDACT/SELECTIVE/FULL per folder. Collapsing to all-FULL with inline `===` credential redaction dramatically simplified the MCP server, vault structure, and mental model.
- **Two vaults solve the privacy problem cleanly.** Rather than complex per-folder access rules within one vault, separating private content into `~/Vaults/private/` eliminates the tension between CC access and personal privacy. The private vault is a deferred topic with its own local LLM.
- **Wikilinks in headings are the routing mechanism.** No config file needed to map daily note headings to projects. `## [[PeerLoop]]` self-declares "PeerLoop" as a project. First use creates the project.
- **Multi-project headings create shared atomic notes.** `## [[PeerLoop]] • [[Cloudflare]]` creates one atomic note linked from both project logs. Cross-referencing for free.
- **Merge rule prevents duplication.** One atomic note per unique heading-signature per day. Multiple entries for the same project on the same day append to the same note.

## Card Types & Records

- **Coding timecards should be CC-generated, not human-entered.** They derive entirely from git commit history. Running `/cco-session-close` from the project repo gives direct git access; no need to route through daily notes.
- **Meeting card covers phone calls and site visits.** The `via` field (Zoom, Phone, Site Visit, In-person) distinguishes them. Optional `from` (who initiated) and `where` (location) fields handle the differences. No need for separate card types.
- **Email bodies should be summarized, not quoted.** Code blocks and blockquotes both have rendering issues. The original email lives in the email client; the card captures the substance as bullet points.
- **Slack cards are timed.** Unlike initial assumption, Slack threads have start/end times and separate fields are better than a compressed single field, since conversations can become billable.

## Workflow & Tooling

- **DataviewJS with external scripts doesn't work on Obsidian mobile (Android/iOS).** This is a hard constraint. Mobile reports must use either basic DQL queries or plain markdown. The CC headless mode on Mac Mini solves this by processing daily notes and writing results as plain markdown that Obsidian renders on any device.
- **CC headless mode (`claude -p`) enables mobile workflows.** Edit daily note on phone → Obsidian Sync to Mac Mini → CC processes headlessly → results sync back. Single source of truth preserved.
- **Versioned schemas + CC migration solves the Obsidian template problem.** Templates are "stamp once" — changing them doesn't update existing notes. Versioned schemas with `/cco-migrate-schema` backfill changes to all existing records of that type.
- **Task importance via `+` symbols is fast entry.** User writes `+++++` in daily notes; CC converts to `[importance:: 5]` during extraction for Dataview queryability.

## PLAN.md Format

- **Named phases with dot-notation beat numbered phases.** Execution order is fluid; naming phases (FOUNDATION, GLOBAL-SKILLS) decouples *what* from *when*. The Current Sequence at the top of PLAN.md is the only place that defines order.
- **COMPLETED-PLAN.md keeps PLAN.md lean.** Full detail of completed phases moves out; PLAN.md retains just the heading + one-line summary with a link.

## Process

- **Global skills need unique prefixes.** The `cco-` prefix prevents collisions with existing global skills from other projects (`q-*`, `par-*`, `r-*`).
- **Never run history-changing git commands without explicit permission.** Rebase, merge, reset --hard, push --force, amend — always explain why and let the user decide. Even when the operation seems safe.

---
## Continued — 19:53

## Implementation

- **CC global skills are markdown prompt files, not code.** The 4 `cco-*` skills (session-close, process-daily, migrate-schema, project-init) are detailed step-by-step instructions in `~/.claude/commands/`. CC interprets and executes them — no TypeScript/Python runtime needed. This means the skills are immediately testable and iterable.
- **Skill files benefit from explicit execution order documentation.** `/cco-session-close` has data dependencies between steps (timecard produces commit-range needed by session note, plan update produces changes needed by session note). Documenting the dependency chain at the bottom of the skill prevents CC from reordering steps.
- **Card marker detection should be loose, not strict.** Emoji and spacing vary between devices and Obsidian versions. Matching on key words (`Timecard` + `Coding`, `Slack`, etc.) rather than exact emoji sequences is more robust.
- **Integration testing with real vault data catches design issues.** The test daily note exposed that the Meristics project folder didn't exist, validating the error handling paths (warn and skip vs. stop). Also confirmed the merge rule works correctly with duplicate `## [[PeerLoop]]` headings.

## Branch Management

- **Always check which branch you're on before making changes.** The PeerLoop repo had `main` as the active branch (which was very out of date). Changes needed to go on `xx3` (branched from `staging`). Stashing, switching, and re-applying was required to fix this.
- **Stash is necessary when switching branches with uncommitted changes.** Even pre-existing modifications (like SESSION-INDEX.md) block checkout. Quick `git stash` → switch → create branch → re-apply is the safe pattern.

---
## Continued — 08:10 (session 4)

## Content Preservation

- **"Defer" means mark as deferred, not delete.** When told to defer, pause, or skip something — add a `*(deferred)*` marker and keep all tasks/detail intact. Only the status changes. I deleted tasks and collapsed MCP-SERVER to a one-liner when told to "defer" it, and had to restore everything.
- **Never make files shorter without explicit instruction.** If content feels removable, confirm the specific content with the user first. This was added as a rule to both CLAUDE.md and MEMORY.md after the incident.

## Architecture & Classification

- **CC's native file tools make MCP server redundant for now.** Glob, Grep, Read, Write provide full vault access. MCP only adds value when semantic search is needed. The entire integration testing session proved this — no MCP server was needed.
- **Folders are for containment, frontmatter for classification.** Folders force single classification (a note can only live in one folder). Frontmatter `type` field handles multi-dimensional classification. This resolves the "where does VS Code go?" problem.
- **`type` should be multi-valued.** Single-valued `type` has the same problem as folders — forces one classification. `type: [vendor, service-provider]` with `WHERE contains(type, "vendor")` queries.
- **One note per entity, split only when unwieldy.** Monolithic vendor notes (one file with everything) beat atomic sub-notes (one per account/service/credential). One file = findable, maintainable, queryable. The user's 30% success rate finding things stems from inconsistent structure, not from notes being too large.
- **The finding problem is a consistency problem.** If every vendor note has `type: [vendor]` in frontmatter, you can always find all vendors. Without consistent frontmatter, no query strategy works.

## Skill Design

- **`/cco-process-daily` must validate project folders before processing.** Wikilink target (before `|`) determines the project name. If the project folder doesn't exist, halt the entire heading — no partial extraction. The user fixes the issue and re-runs.
- **Don't reason about what IS a project.** `[[Gabriel Rymberg|Gabriel]]` might look like a person reference, but the skill's job is mechanical: check if the folder exists, process if yes, skip if no. No interpretation.
- **Entity schemas are for consistency, not creation automation.** Building a generic `/cco-create` skill optimizes for the rare case (creating entities) at the cost of complexity. Schemas earn their keep through queryability and migration, not through creation shortcuts.
