# Session Decisions — 2026-02-11 07:46

## Decision 1: ENTITIES.md replaces HOW-TO.md

**Context**: Started with HOW-TO.md for vault task recipes, iterated through PLAYBOOK.md, landed on ENTITIES.md.

**Options Considered**:
1. HOW-TO.md — procedural recipes for CC
2. PLAYBOOK.md — collection of plays/procedures
3. ENTITIES.md — entity-centric guide ← Chosen

**Decision**: Create ENTITIES.md as a guide to entity types in the vault — what they are, how they're structured, what's nested, and what you can ask CC to do.

**Rationale**: The document's real value is as a human menu and entity model reference, not a procedure manual. Entity framing naturally captures sub-resource nesting (accounts inside vendors, plugins inside software) and cross-entity relationships.

## Decision 2: Software schema — flexible ## headings

**Context**: Designing the software entity schema, needed to decide on heading conventions.

**Options Considered**:
1. By topic — ## Quick Links, ## Setup, ## Gotchas
2. By version — ## v4.0, ## v3.x
3. Flexible / per-note ← Chosen

**Decision**: No prescribed `##` convention for software notes. Each note organizes however makes sense.

**Rationale**: Software notes vary too much — a desktop app note looks nothing like a library note. Vendors have a natural `##` = account convention; software doesn't have an equivalent universal division.

## Decision 3: Software location — reference/software/

**Context**: Software notes could go in existing reference/tech-notes/ or a new folder.

**Options Considered**:
1. reference/software/ — new folder ← Chosen
2. reference/tech-notes/ — use existing empty folder

**Decision**: Create reference/software/ parallel to reference/vendors/. tech-notes/ remains available for non-entity reference material.

**Rationale**: Clean entity separation. Software notes are entities with schemas; tech-notes/ is for broader reference material (patterns, checklists, snippets) if ever needed.

## Decision 4: repository field in software frontmatter

**Context**: Whether to put GitHub/GitLab URLs in frontmatter or body.

**Options Considered**:
1. Frontmatter field ← Chosen
2. Body only (in Quick Links)

**Decision**: Add `repository` as an optional frontmatter field.

**Rationale**: Queryable via Dataview, unlike a body link.

## Decision 5: aliases field added to entity schemas

**Context**: Old vault notes had aliases (VS Code / Visual Studio Code, Droid CLI / Droid). Needed to decide how to handle alternate names.

**Options Considered**:
1. Add aliases to schema ← Chosen
2. Body only — mention alternate names in text

**Decision**: Added `aliases` list field to software schema (v1, pre-notes) and vendor schema (v2, backfilled 8 notes).

**Rationale**: Obsidian-native field — values resolve as wikilink targets. Essential for tools and vendors known by multiple names.

## Decision 6: Software credentials — case by case

**Context**: Old notes mixed credentials in software and vendor contexts. Needed a rule.

**Options Considered**:
1. Always in software note
2. Always in vendor note
3. Either, case by case ← Chosen

**Decision**: License keys and tool-specific logins go in the software note. Purchase history and payment details may go in a vendor note for the seller. No strict rule.

**Rationale**: Put it where you'd look for it first.

## Decision 7: type list for software classification

**Context**: Old vault used hierarchical tags (software/desktop, software/javascript/library). Needed a new approach.

**Options Considered**:
1. type list only ← Chosen
2. Separate platform/category fields
3. Don't classify

**Decision**: Use the type list for cross-cutting classification: `[software, desktop-app]`, `[software, cli-tool]`, etc.

**Rationale**: Consistent with vendor pattern. One or two secondary values is typical — don't over-classify.

## Decision 8: Google Gemini is a software note, not a vendor section

**Context**: Gemini is a Google product but also a tool you interact with directly.

**Options Considered**:
1. Software note ← Chosen
2. Section inside Google vendor note

**Decision**: Create reference/software/GoogleGemini.md separately from the Google vendor note.

**Rationale**: Gemini is a tool you use directly, like Claude Code. Google vendor note holds the account relationship.

## Decision 9: Otter AI and Stream are vendors

**Context**: Both sit on the software/vendor boundary.

**Options Considered**:
1. Both vendors ← Chosen
2. Both software
3. Mixed

**Decision**: Both are vendor notes — they're SaaS services you consume with accounts.

**Rationale**: The vendor vs. software rule: if you have an account with it and consume it as a service, it's a vendor.

## Decision 10: Three separate Claude product notes

**Context**: Anthropic - Claude, Claude Code, and Claude Desktop were 3 old notes.

**Options Considered**:
1. 3 separate notes ← Chosen
2. One consolidated Claude note
3. 2 notes (Claude + Claude Code)

**Decision**: AnthropicClaude.md, ClaudeCode.md, ClaudeDesktop.md — three separate software notes.

**Rationale**: They're distinct tools with different usage patterns. The Anthropic vendor note holds the account/API keys.

## Decision 11: Obsidian Cheatsheet and Tools merge into Obsidian software note

**Context**: Two old reference notes about Obsidian conventions and tools.

**Options Considered**:
1. Obsidian software note ← Chosen
2. reference/tech-notes/
3. Skip both

**Decision**: Create reference/software/Obsidian.md and merge cheatsheet and tools content as sections.

**Rationale**: The content is about the Obsidian tool itself (hotkeys, conventions, AI chat import). Fits naturally as sections within the entity note.

---
## Continued — 10:09

## Decision 12: Person note location — reference/people/

**Context**: ENTITIES.md listed person location as TBD — either `reference/people/` or `business/contacts/`.

**Options Considered**:
1. reference/people/ ← Chosen
2. business/contacts/

**Decision**: `reference/people/{FirstLast}.md` — parallel to `reference/vendors/` and `reference/software/`.

**Rationale**: People are reference entities like vendors and software, not business operations. Consistent folder structure.

## Decision 13: Alias collisions — accepted risk

**Context**: Short first-name aliases (Mike, Colin, Katie) could collide if a second person shares the name.

**Options Considered**:
1. Accept risk, handle at creation time ← Chosen
2. Drop first-name aliases preemptively
3. Never use bare first names

**Decision**: Keep short aliases. Obsidian's autocomplete disambiguates at entry time. Check for collisions when creating new people or migrating old daily notes.

**Rationale**: Low volume of people notes makes collisions unlikely. The autocomplete dropdown is the natural safety net.

## Decision 14: Decouple /cco-project-init from repo linking

**Context**: `/cco-project-init` created both vault folder and updated repo CLAUDE.md. Many future projects (hobby, in-house) won't have repos.

**Options Considered**:
1. Decouple into two skills ← Chosen
2. Make repo step optional via flag
3. Keep combined, skip repo step manually

**Decision**: `/cco-project-init` creates vault folder only. New `/cco-project-link-repo` handles repo linking separately.

**Rationale**: Keeps each skill focused on one concern. Any project can use init; only coding projects need link-repo. User wanted consistency — both as skills.

## Decision 15: Multi-phase projects — phases as regular projects

**Context**: XLATE has an umbrella (XLATE-0) and phases (XLATE-Pilot, future phases). Need a pattern that works for other multi-phase projects too.

**Options Considered**:
1. Phases as regular projects with parent links ← Chosen
2. Phases as subfolders within one project folder
3. Phases as sections within one project note
4. Parent project + child projects with schema `parent` field

**Decision**: Each phase is a full project with its own folder, status, tasks, plan, sessions. Umbrella project holds business info and a `## Phases` table. Relationship is wikilinks in the body — no schema changes.

**Rationale**: Uses existing conventions with zero new machinery. Each phase gets independent lifecycle (status, plan, sessions). Simple and extensible.

## Decision 16: Meristics/Technifar unification

**Context**: frasergorrie.com website had multiple historical names (Meristics, Technifar, bio-software) spread across 7 old vault notes.

**Options Considered**:
1. Meristics = project, Technifar = business entity ← Chosen
2. frasergorrie.com = project name
3. Single combined note

**Decision**: `projects/meristics/Meristics.md` is the website project with aliases for all domain names. `business/Technifar.md` is the corporate entity with aliases for historical names.

**Rationale**: Separates the thing being built (website) from the entity that owns it (company). "Meristics" is already the account name in vendor notes. Aliases unify all historical names.

## Decision 17: Client work done for free — still client-work type

**Context**: StickerHardlyKnowHer is built for Katie Gorrie but unpaid.

**Options Considered**:
1. [project, client-work] ← Chosen
2. [project, hobby]

**Decision**: The relationship determines the type, not the payment.

**Rationale**: It's built for a client (Katie) with client requirements, deliverables, and a domain. The "freebie" aspect is a billing detail, not a classification one.

## Decision 18: Client organizations in business/ folder

**Context**: CenterForUnity is a client org — not a vendor, not software, not a person. Needed a home.

**Options Considered**:
1. business/ folder ← Chosen
2. New reference/organizations/ folder
3. Stretch vendor definition to include clients

**Decision**: Client organizations go in `business/` with `type: [organization, client]`.

**Rationale**: The `business/` folder is designated for "Clients, proposals, operations." Client orgs are business entities, not reference material. No new entity schema needed at this volume.
